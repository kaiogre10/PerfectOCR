PerfectOCR - Estructura 
.
└── perfectocr/
    ├── cli/                                  # (Command-Line Interface) Interfaz de línea de comandos.
    │   ├── __init__.py                       # Facilita la importación del módulo 'app' de Typer desde el paquete cli.
    │   └── main.py                           # Punto de entrada de la aplicación. Usa Typer para los comandos 'run' y 'benchmark'. Parsea argumentos, encuentra imágenes y delega el trabajo al `WorkflowManager`.
    │
    ├── core/                                 # Contiene toda la lógica de negocio y procesamiento del proyecto.
    │   ├── coordinators/                     # "Directores de Orquesta". Gestionan las fases principales del flujo de trabajo, delegando las tareas a los "workers" especializados.
    │   │   ├── ocr_coordinator.py            # Inicializa y gestiona el motor OCR (PaddleOCR). Recibe la imagen preprocesada, realiza el reconocimiento de texto y empaqueta los resultados (texto, polígonos, confianza) en un JSON estandarizado.
    │   │   ├── preprocessing_coordinator.py  # Gestiona el preprocesamiento de imágenes. Delega el análisis y la corrección al `ImageQualityEvaluator` para mejorar la imagen antes del OCR.
    │   │   ├── tensor_coordinator.py         # Orquesta la "vectorización". Su función principal es transformar los resultados brutos del OCR (una nube de polígonos) en datos religles y ordenados.
    │   │   └── text_cleaning_coordinator.py  # Coordina la limpieza del texto extraído. Usa `TextCleaner` para una limpieza segura de bajo nivel (preservando códigos/números) y `TextCorrector` para correcciones más complejas (ortografía) basadas en diccionarios.
    │   │
    │   ├── workspace/                        # "Espacio" de trabajo donde se centralizan las herramientas para trabajar y el espacio de trabajo.
    │   │   ├── domain/                       # Define las estructuras de datos (modelos) clave del proyecto.
    │   │   │   ├── main_job.py               # Define la dataclass `ProcessingJob`, que representa una unidad de trabajo (una imagen) y su estado a lo largo del pipeline.
    │   │   │   └── vector_models.py          # Define las dataclasses para los vectores (`ElementalVector`, `AtomicVector`, `DifferetiatorVector`, etc.), que son las estructuras de datos fundamentales de la fase de "vectorización".
    │   │   └── utils/                        # Herramientas y utilidades genéricas usadas en todo el proyecto.
    │   │       ├── __init__.py               # Archivo estándar que permite que el directorio 'utils' sea tratado como un paquete.
    │   │       ├── batch_tools.py            # Contiene funciones para el procesamiento por lotes, como dividir tareas en chunks (`chunked`) y estimar tiempos.
    │   │       ├── encoders.py               # Contiene `NumpyEncoder`, una clase crucial que permite guardar estructuras con tipos de NumPy (arrays, int64, etc.) en archivos JSON.
    │   │       ├── geometric.py              # Biblioteca de funciones para realizar cálculos geométricos sobre los polígonos del OCR (límites, centros, áreas, IoU, etc.).
    │   │       └── output_handlers.py        # Clases especializadas (`JsonOutputHandler`, `ImageOutputHandler`, `TextOutputHandler`, `ExcelOutputHandler`) para guardar de manera estandarizada los diferentes tipos de archivos de salida.
    │   │
    │   └── workflow/                         # "Workers". Contiene los algoritmos específicos para cada paso.
    │       ├── ocr/                          # Lógica específica de los motores de OCR.
    │       │   └── paddle_wrapper.py         # "Wrapper" o envoltorio para la librería PaddleOCR. Adapta la entrada y la salida de PaddleOCR al formato que el proyecto espera, aislando la dependencia de esta librería.
    │       ├── preprocessing/                # Algoritmos y herramientas para la mejora de la calidad de la imagen.
    │       │   ├── quality_validator.py      # Contiene `ImageQualityEvaluator`. El "cerebro" del preprocesamiento: analiza la imagen para detectar problemas (inclinación, ruido, Moiré) y decide qué funciones del `toolbox` aplicar.
    │       │   └── toolbox.py                # "Caja de herramientas" con funciones puras de procesamiento de imágenes (rotar, aplicar filtros, corregir contraste, etc.) llamadas por `ImageQualityEvaluator`.
    │       ├── text_cleaning/                # Módulos especializados en la limpieza y corrección del texto.
    │       │   ├── text_cleaner.py           # Realiza una limpieza de texto de "alta seguridad", eliminando caracteres "basura" del OCR sin arriesgarse a alterar datos importantes como códigos o valores numéricos.
    │       │   └── text_corrector.py         # Realiza correcciones de texto más avanzadas y arriesgadas, usando diccionarios y algoritmos de distancia de edición para corregir errores ortográficos en palabras.
    │       └── vectorial_transformation/     # Lógica para transformar los polígonos de OCR en representaciones vectoriales estructuradas.
    │           ├── math_max.py               # Contiene la clase `MatrixSolver`. Su función es resolver y corregir inconsistencias aritméticas en una tabla. Busca la hipótesis más probable para las columnas (Cantidad, P. Unitario, Total) y reconstruye la matriz para que sea matemáticamente coherente.
    │           ├── density_scanner.py        # Script de análisis/prototipo. Usa "densidad" de caracteres y clustering (DBSCAN) para intentar detectar automáticamente las líneas de una tabla en un documento.
    │           ├── subset_grouper.py         # Algoritmo fundamental. Toma la "nube" de polígonos del OCR y los agrupa en líneas horizontales coherentes basándose en la alineación vertical de sus centroides.
    │           ├── tensorizer.py             # "Meta-vectorizador". Orquesta la creación de los diferentes tipos de vectores (`Atomic`, `Elemental`, `Differential`) delegando la tarea a los `vectorizers` especializados.
    │           └── vectorizers/              # Clases que implementan la lógica para crear cada tipo específico de vector.
    │               ├── atomic_vectorizer.py  # Genera `AtomicVector`, que representa cada carácter con su "densidad" y su posición relativa en la línea.
    │               ├── density_enconder.json # Archivo de datos crítico. Mapea cada carácter posible a un valor numérico de "densidad", que es la base de los vectores atómicos y los perfiles morfológicos.
    │               ├── differenciator_vectorizer.py # Genera `DifferetiatorVector`, con estadísticas agregadas de una línea para compararla con la siguiente y detectar cambios estructurales.
    │               └── elemental_vectorizer.py      # Genera `ElementalVector`, la representación más rica de un polígono de texto. Contiene sus escalares geométricos, morfológicos y relacionales.
    │
    ├── management/                            # Gestión de alto nivel del flujo de trabajo completo.
    │    ├── workflow_manager.py              # Clase principal que decide el modo (lote/interactivo).
    │    └── config_manager.py                # Clase principal que gestiona y reparte la configuración a cada módulo
    │    
    ├── config/                               # Apartado que contine los parametros
    │   └── master_config.yaml                # Archivo que funciona como un panel de control en el que se deciden todos los parametros, rutas y configuraciones de todos los módulos.
    │
    └── main.py                               # Archivo de entrada que incia todo el proceso, inicializa los coordinadores y los llama en la secuencia correcta: Preprocesamiento -> OCR -> Limpieza de Texto -> Vectorización. Gestiona el ciclo de vida de cada `ProcessingJob`.