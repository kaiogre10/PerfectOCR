"""
This type stub file was generated by pyright.
"""

from sklearn.base import BaseEstimator, MultiOutputMixin, RegressorMixin
from daal4py.sklearn._n_jobs_support import control_n_jobs
from daal4py.sklearn._utils import daal_check_version, sklearn_check_version
from onedal.common.hyperparameters import get_hyperparameters
from .._device_offload import wrap_output_data
from .._utils import register_hyperparameters
from ..base import oneDALEstimator

if sklearn_check_version("1.2"):
    ...
@register_hyperparameters({ "fit": get_hyperparameters("linear_regression", "train"),"partial_fit": get_hyperparameters("linear_regression", "train") })
@control_n_jobs(decorated_methods=["fit", "partial_fit", "predict", "score", "_onedal_finalize_fit"])
class IncrementalLinearRegression(MultiOutputMixin, RegressorMixin, oneDALEstimator, BaseEstimator):
    """
    Incremental Ordinary least squares Linear Regression.

    Trains a linear regression model, allows for computation if the data
    are split into batches. The user can use the ``partial_fit`` method
    to provide a single batch of data or use the ``fit`` method to provide
    the entire dataset.

    Parameters
    ----------
    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to False, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    copy_X : bool, default=True
        If True, X will be copied; else, it may be overwritten.

    n_jobs : int, default=None
        The number of jobs to use for the computation.

    batch_size : int, default=None
        The number of samples to use for each batch. Only used when calling
        ``fit``. If ``batch_size`` is ``None``, then ``batch_size``
        is inferred from the data and set to ``5 * n_features``.

    Attributes
    ----------
    coef_ : array of shape (n_features, ) or (n_targets, n_features)
        Estimated coefficients for the linear regression problem.
        If multiple targets are passed during the fit (y 2D), this
        is a 2D array of shape (n_targets, n_features), while if only
        one target is passed, this is a 1D array of length n_features.

    intercept_ : float or array of shape (n_targets,)
        Independent term in the linear model. Set to 0.0 if
        `fit_intercept = False`.

    n_samples_seen_ : int
        The number of samples processed by the estimator. Will be reset on
        new calls to ``fit``, but increments across ``partial_fit`` calls.
        It should be not less than `n_features_in_` if `fit_intercept`
        is False and not less than `n_features_in_` + 1 if `fit_intercept`
        is True to obtain regression coefficients.

    batch_size_ : int
        Inferred batch size from ``batch_size``.

    n_features_in_ : int
        Number of features seen during ``fit`` or ``partial_fit``.

    Notes
    -----
    Sparse data formats are not supported. Input dtype must be ``float32`` or ``float64``.

    %incremental_serialization_note%

    Examples
    --------
    >>> import numpy as np
    >>> from sklearnex.linear_model import IncrementalLinearRegression
    >>> inclr = IncrementalLinearRegression(batch_size=2)
    >>> X = np.array([[1, 2], [3, 4], [5, 6], [7, 10]])
    >>> y = np.array([1.5, 3.5, 5.5, 8.5])
    >>> inclr.partial_fit(X[:2], y[:2])
    >>> inclr.partial_fit(X[2:], y[2:])
    >>> inclr.coef_
    np.array([0.5., 0.5.])
    >>> inclr.intercept_
    np.array(0.)
    >>> inclr.fit(X)
    >>> inclr.coef_
    np.array([0.5., 0.5.])
    >>> inclr.intercept_
    np.array(0.)
    """
    __doc__ = ...
    _onedal_incremental_linear = ...
    if sklearn_check_version("1.2"):
        _parameter_constraints: dict = ...
    def __init__(self, *, fit_intercept=..., copy_X=..., n_jobs=..., batch_size=...) -> None:
        ...
    
    _onedal_cpu_supported = ...
    _onedal_gpu_supported = ...
    if daal_check_version((2025, "P", 200)):
        ...
    else:
        ...
    @property
    def intercept_(self): # -> Any:
        ...
    
    @intercept_.setter
    def intercept_(self, value): # -> None:
        ...
    
    @property
    def coef_(self): # -> Any:
        ...
    
    @coef_.setter
    def coef_(self, value): # -> None:
        ...
    
    def partial_fit(self, X, y, check_input=...): # -> Self:
        """
        Incremental fit with X and y. X and y are processed as a single batch.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where ``n_samples`` is the number of samples and
            `n_features` is the number of features.

        y : array-like of shape (n_samples,) or (n_samples, n_targets)
            Target values, where ``n_samples`` is the number of samples and
            ``n_targets`` is the number of targets.

        check_input : bool, default=True
            Run validate_data on X and y.

        Returns
        -------
        self : IncrementalLinearRegression
            Returns the instance itself.
        """
        ...
    
    def fit(self, X, y): # -> Self:
        """
        Fit the model with X and y, using minibatches of size ``batch_size``.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where ``n_samples`` is the number of samples and
            ``n_features`` is the number of features. It is necessary for
            ``n_samples`` to be not less than ``n_features`` if ``fit_intercept``
            is False and not less than ``n_features + 1`` if ``fit_intercept``
            is 'True'.

        y : array-like of shape (n_samples,) or (n_samples, n_targets)
            Target values, where ``n_samples`` is the number of samples and
            ``n_targets`` is the number of targets.

        Returns
        -------
        self : IncrementalLinearRegression
            Returns the instance itself.
        """
        ...
    
    @wrap_output_data
    def predict(self, X, y=...): # -> Any:
        ...
    
    @wrap_output_data
    def score(self, X, y, sample_weight=...): # -> Any:
        ...
    


