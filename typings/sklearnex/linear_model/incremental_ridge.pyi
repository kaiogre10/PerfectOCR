"""
This type stub file was generated by pyright.
"""

from sklearn.base import BaseEstimator, MultiOutputMixin, RegressorMixin
from daal4py.sklearn._n_jobs_support import control_n_jobs
from daal4py.sklearn.utils.validation import sklearn_check_version
from .._device_offload import wrap_output_data
from ..base import oneDALEstimator

if sklearn_check_version("1.2"):
    ...
@control_n_jobs(decorated_methods=["fit", "partial_fit", "predict", "score", "_onedal_finalize_fit"])
class IncrementalRidge(MultiOutputMixin, RegressorMixin, oneDALEstimator, BaseEstimator):
    """
    Incremental estimator for Ridge Regression.

    Allows to train Ridge Regression if data is split into batches.

    Parameters
    ----------
    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to False, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    alpha : float, default=1.0
        Regularization strength; must be a positive float. Regularization
        improves the conditioning of the problem and reduces the variance of
        the estimates. Larger values specify stronger regularization.

    copy_X : bool, default=True
        If True, X will be copied; else, it may be overwritten.

    n_jobs : int, default=None
        The number of jobs to use for the computation.

    batch_size : int, default=None
        The number of samples to use for each batch. Only used when calling
        ``fit``. If ``batch_size`` is ``None``, then ``batch_size``
        is inferred from the data and set to ``5 * n_features``, to provide a
        balance between approximation accuracy and memory consumption.

    Attributes
    ----------
    coef_ : array of shape (n_features, ) or (n_targets, n_features)
        Estimated coefficients for the ridge regression problem.
        If multiple targets are passed during the fit (y 2D), this
        is a 2D array of shape (n_targets, n_features), while if only
        one target is passed, this is a 1D array of length n_features.

    intercept_ : float or array of shape (n_targets,)
        Independent term in the linear model. Set to 0.0 if
        `fit_intercept = False`.

    n_features_in_ : int
        Number of features seen during :term:`fit`.

    n_samples_seen_ : int
        The number of samples processed by the estimator. Will be reset on
        new calls to fit, but increments across ``partial_fit`` calls.
        It should be not less than `n_features_in_` if `fit_intercept`
        is False and not less than `n_features_in_` + 1 if `fit_intercept`
        is True to obtain regression coefficients.

    batch_size_ : int
        Inferred batch size from ``batch_size``.

    Notes
    -----
    Sparse data formats are not supported. Input dtype must be ``float32`` or ``float64``.

    %incremental_serialization_note%
    """
    __doc__ = ...
    _onedal_incremental_ridge = ...
    if sklearn_check_version("1.2"):
        _parameter_constraints: dict = ...
    def __init__(self, fit_intercept=..., alpha=..., copy_X=..., n_jobs=..., batch_size=...) -> None:
        ...
    
    _onedal_cpu_supported = ...
    _onedal_gpu_supported = ...
    def partial_fit(self, X, y, check_input=...): # -> Self:
        """
        Incrementally fits with X and y. X and y are processed as a single batch.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where `n_samples` is the number of samples and
            `n_features` is the number of features.

        y : array-like of shape (n_samples,) or (n_samples, n_targets)
            Target values, where `n_samples` is the number of samples and
            `n_targets` is the number of targets.

        check_input : bool, default=True
            Run validate_data on X and y.

        Returns
        -------
        self : IncrementalRidge
            Returns the instance itself.
        """
        ...
    
    def fit(self, X, y): # -> Self:
        """
        Fit the model with X and y, using minibatches of size ``batch_size``.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where `n_samples` is the number of samples and
            ``n_features`` is the number of features. It is necessary for
            ``n_samples`` to be not less than ``n_features`` if ``fit_intercept``
            is False and not less than ``n_features`` + 1 if ``fit_intercept``
            is True.

        y : array-like of shape (n_samples,) or (n_samples, n_targets)
            Target values, where `n_samples` is the number of samples and
            `n_targets` is the number of targets.

        Returns
        -------
        self : IncrementalRidge
            Returns the instance itself.
        """
        ...
    
    @wrap_output_data
    def predict(self, X, y=...): # -> Any:
        ...
    
    @wrap_output_data
    def score(self, X, y, sample_weight=...): # -> Any:
        ...
    
    @property
    def coef_(self): # -> Any:
        ...
    
    @coef_.setter
    def coef_(self, value): # -> None:
        ...
    
    @property
    def intercept_(self): # -> Any:
        ...
    
    @intercept_.setter
    def intercept_(self, value): # -> None:
        ...
    


